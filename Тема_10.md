Тема 10. Декораторы и исключения.
Отчет по Теме #10 выполнил:
- **Хамдамбеков Санжарбек Акбарбекович**
- **ИВТ-23-1**

| Задание | Лаб_раб | Сам_раб |
| ------ | -------- | ------- |
| Задание 1 | +     |     +   |
| Задание 2 | +     |      
| Задание 3 | +     |     
| Задание 4 | +     |     
| Задание 5 | +     |    

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- Ассистент кафедры информационных технологий и статистики, Ротенштрайх Татьяна Викторовна.

## Лабораторная работа №1

![Uploading 1.jpg…]()
from functools import lru_cache

@lru_cache(None)
def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    return fibonacci(n - 1) + fibonacci(n - 2)

if __name__ == '__main__':
    print(fibonacci(100))
## Лабораторная работа №2

![Uploading 2.jpg…]()
def check(input_func):
    def output_func(*args):
        name, age = args[0], args[1]

        if age < 0 or age > 130:
            age = 'Недопустимый возраст'
        input_func(name, age)

    return output_func


@check
def personal_info(name, age):
    print(f"Name: {name} Age: {age}")


if __name__ == '__main__':
    personal_info('Владимир', 38)
    personal_info('Александр', -5)
    personal_info('Петр', 138)
## Лабораторная работа №3

![Uploading 3.jpg…]()
def data(*args):
    try:
        for i in range(len(args[0])):
            try:
                result = (args[0][i] * 15) // 10
                print(result)
            except Exception as ex:
                print(ex)
    except Exception as ex:
        print(ex)
    finally:
        print('Вся информация обработана')

if __name__ == '__main__':
    data([1, 15, 'Hello', 'i', 'try', 'to', 'crash', 'your', 'site', 38, 45])
## Лабораторная работа №4

![Uploading 4.jpg…]()
class NegativeValueException(Exception):
    pass

def check_name(name):
    if len(name) > 10:
        raise NegativeValueException('Длина более 10 символов')
    else:
        print('Успешная регистрация')
if __name__ == '__main__':
    name = '12345678910'
    check_name(name)
## Лабораторная работа №5

![Uploading 5.jpg…]()
class SiteChecker:
    def __init__(self, func):
        print('> Класс SiteChecker метод __init__ успешный запуск')
        self.func = func

    def __call__(self):
        print('> Проверка перед запуском', self.func.__name__)
        self.func()
        print('> Проверка безопасного выключения')

@SiteChecker
def site():
    print('Усердная работа сайта')

if __name__ == '__main__':
    print('>> Сайт запущен')
    site()
    print('>> Сайт выключен')
    
## Самостоятельная работа №1
![Uploading 1 сам.jpg…]()

import time


def timer(func):
    def wrapper():
        start_time = time.time()
        func()
        end_time = time.time()
        execution_time = end_time - start_time
        print(f"\nВремя выполнения программы: {execution_time:.6f} секунд")

    return wrapper


@timer
def fibonacci():
    fib1 = fib2 = 1
    print(fib1, fib2, end=' ')

    for i in range(2, 200):
        fib1, fib2 = fib2, fib1 + fib2
        print(fib2, end=' ')


if __name__ == '__main__':
    fibonacci()

## Самостоятельная работа №2
![Uploading image.png…]()

def read_file(filename):
    try:
        with open(filename, 'r', encoding='utf-8') as file:
            content = file.read()
            if not content.strip():
                raise Exception("файл пустой")
            else:
                print("Содержимое файла:")
                print(content)
    except FileNotFoundError:
        print(f"Файл {filename} не найден")
    except Exception as e:
        print(e)

def create_test_files():
    with open("empty_file.txt", 'w', encoding='utf-8') as f:
        pass

    with open("file_with_content.txt", 'w', encoding='utf-8') as f:
        f.write("Это тестовый файл с содержимым\n")
        f.write("Здесь есть информация для обработки\n")
        f.write("Файл не пустой!")


if __name__ == '__main__':
    create_test_files()

    print("Проверка пустого файла:")
    read_file("empty_file.txt")

    print("\nПроверка файла с содержимым:")
    read_file("file_with_content.txt")

    print("\nПроверка несуществующего файла:")
    read_file("nonexistent_file.txt")
## Самостоятельная работа №3
![Uploading image.png…]()

def add_two():
    try:
        user_input = input("Введите число: ")
        number = float(user_input)  # Пробуем преобразовать ввод в число
        result = 2 + number
        print(f"Результат: 2 + {number} = {result}")
        return result
    except ValueError:
        print("Неподходящий тип данных. Ожидалось число.")

if __name__ == '__main__':
    print("=== Тест 1: Корректный ввод (целое число) ===")
    add_two()

    print("\n=== Тест 2: Корректный ввод (дробное число) ===")
    add_two()

    print("\n=== Тест 3: Некорректный ввод (строка) ===")
    add_two()

    print("\n=== Тест 4: Некорректный ввод (специальные символы) ===")
    add_two()
## Самостоятельная работа №4
![Uploading image.png…]()

import time
import random
from functools import wraps

class RetryDecorator:

    def __init__(self, max_attempts=3, delay=1):
        self.max_attempts = max_attempts
        self.delay = delay

    def __call__(self, func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            last_exception = None

            for attempt in range(self.max_attempts):
                try:
                    print(f"Попытка {attempt + 1}/{self.max_attempts} для {func.__name__}")
                    result = func(*args, **kwargs)
                    print(f"{func.__name__} выполнена успешно!")
                    return result

                except Exception as e:
                    last_exception = e
                    print(f"Ошибка в {func.__name__}: {e}")

                    if attempt < self.max_attempts - 1:
                        print(f"Повтор через {self.delay} сек...")
                        time.sleep(self.delay)
                    else:
                        print(f"Все попытки для {func.__name__} исчерпаны!")

            raise last_exception if last_exception else Exception("Неизвестная ошибка")

        return wrapper

@RetryDecorator(max_attempts=3, delay=1)
def safe_divide(a: float, b: float) -> float:
    if b == 0:
        raise ValueError("Деление на ноль!")
    result = a / b
    print(f"{a} / {b} = {result:.2f}")
    return result

@RetryDecorator(max_attempts=4, delay=2)
def mock_api_request(endpoint: str) -> dict:
    errors = [
        "Таймаут соединения",
        "Сервер недоступен",
        "Ошибка авторизации",
        "Превышен лимит запросов"
    ]

    if random.random() < 0.4:
        raise ConnectionError(random.choice(errors))

    response = {"status": "success", "data": f"Ответ от {endpoint}", "timestamp": time.time()}
    print(f"API запрос к {endpoint} выполнен")
    return response

def create_test_file():
    with open('config.txt', 'w', encoding='utf-8') as f:
        f.write("database=localhost:5432\napi_key=secret123\nmode=production")

def main():
    print("Тестирование декоратора RetryDecorator\n")

    create_test_file()

    print("1. Тест успешного деления:")
    print("-" * 40)
    safe_divide(15, 3)

    print("\n2. Тест деления на ноль:")
    print("-" * 40)
    try:
        safe_divide(10, 0)
    except Exception as e:
        print(f"Финальный результат: {e}")

    print("\n3. Тест API запросов:")
    print("-" * 40)
    try:
        response = mock_api_request("/api/users")
        print(f"Получен ответ: {response}")
    except Exception as e:
        print(f"Финальный результат: {e}")

    print("\n4. Тест успешного API запроса:")
    print("-" * 40)
    random.seed(42)
    try:
        response = mock_api_request("/api/data")
        print(f"Получен ответ: {response}")
    except Exception as e:
        print(f"Финальный результат: {e}")

if __name__ == '__main__':
    main()
## Самостоятельная работа №5
![Uploading image.png…]()

class InsufficientFundsError(Exception):
    def __init__(self, balance: float, amount: float):
        super().__init__(f"Баланс: {balance:.2f}, требуется: {amount:.2f}")

class InvalidAccountError(Exception):
    def __init__(self, operation: str, reason: str):
        super().__init__(f"Операция '{operation}': {reason}")

class BankAccount:
    def __init__(self, name: str, balance: float = 0.0):
        self.name = name
        self.balance = balance
        self.active = True

    def deposit(self, amount: float):
        self._validate("пополнение", amount)
        self.balance += amount
        print(f"{self.name}: +{amount:.2f} руб.")

    def withdraw(self, amount: float):
        self._validate("снятие", amount)
        if amount > self.balance:
            raise InsufficientFundsError(self.balance, amount)
        self.balance -= amount
        print(f"{self.name}: -{amount:.2f} руб.")

    def _validate(self, operation: str, amount: float):
        if not self.active:
            raise InvalidAccountError(operation, "счет заблокирован")
        if amount <= 0:
            raise InvalidAccountError(operation, "сумма должна быть > 0")


def demo():
    accounts = [
        BankAccount("Алексей", 1000.0),
        BankAccount("Мария", 500.0),
        BankAccount("Иван", 200.0)
    ]

    print("ДЕМО ИСКЛЮЧЕНИЙ\n")

    print("1. УСПЕШНЫЕ ОПЕРАЦИИ:")
    accounts[0].deposit(300.0)
    accounts[1].withdraw(150.0)

    print("\n2. ОШИБКИ:")
    try:
        accounts[2].withdraw(500.0)
    except InsufficientFundsError as e:
        print(f"Недостаточно средств: {e}")

    try:
        accounts[0].deposit(-100.0)
    except InvalidAccountError as e:
        print(f"Невалидная операция: {e}")

    print("\n3. БЛОКИРОВКА СЧЕТА:")
    accounts[1].active = False
    try:
        accounts[1].withdraw(100.0)
    except InvalidAccountError as e:
        print(f"Ошибка счета: {e}")

    print("\n4. ИТОГИ:")
    for acc in accounts:
        status = "активен" if acc.active else "заблокирован"
        print(f" {acc.name}: {acc.balance:.2f} руб. ({status})")

if __name__ == "__main__":
    demo()
Вывод:
1. Освоение декораторов:
Создание собственных декораторов для измерения времени выполнения
Понимание принципа обертывания функций
Практическое применение @wraps для сохранения метаданных

2. Работа с исключениями:
Создание пользовательских исключений
Правильная обработка встроенных исключений (ValueError, FileNotFoundError)
Понимание иерархии исключений
